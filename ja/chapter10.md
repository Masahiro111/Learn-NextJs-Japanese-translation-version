# 部分プリレンダリング（オプション）

> 部分プリレンダリングは、Next.js 14 で導入された実験的な機能です。このページの内容は、機能の安定性が進むにつれて更新される可能性があります。実験的な機能を使用したくない場合は、この章をスキップしてもよいでしょう。この章はコースを完了するために必須ではありません。

この章で取り上げるトピックは以下のとおりです。

- 部分プリレンダリングとは何か
- 部分プリレンダリングの仕組み

## 静的コンテンツと動的コンテンツの結合

現在、ルート内で [動的関数](https://nextjs.org/docs/app/building-your-application/routing/route-handlers#dynamic-functions) を呼び出すと（例：`noStore()`、`cookies()` など） ルート全体が動的になります。

今日、ほとんどの Web アプリはこのように作成されています。静的レンダリングと動的レンダリングのどちらかを **アプリケーション全体** または **特定のルート** に対して選択します。

ただし、たいていのルートが完璧に静的または動的というわけではありません。静的コンテンツと動的コンテンツの両方を含むルートがある場合があります。たとえば、[e コマースサイト](https://partialprerendering.com/) について考えてみましょう。商品ページの大部分をプリレンダリングできる場合もありますが、ユーザーのカートとおすすめ商品を必要に応じて動的に取得したい場合もあります。

ダッシュボードページに戻って、静的なコンポーネントと動的なコンポーネントはどれだと思いますか？？

準備ができたら、ダッシュボードのルートをどのように分割するかを見てみましょう。

![サイドナビゲーションが静的で、ページの子コンポーネントが動的であることを示す図](/_images/dashboard-static-dynamic-components.avif)

- `<SideNav>` コンポーネントはデータに依存せず、ユーザーに合わせてパーソナライズされないので `静的` であることができます
- `<Page>` 内のコンポーネントは頻繁に変更されるデータに依存しており、ユーザーに合わせてカスタマイズされるため `動的` にすることができます。

## 部分プリレンダリングとは？

Next.js 14 には、**部分プリレンダリング** のプレビューが含まれています。これは実験的な機能で、ルートを静的な読み込みシェルでレンダリングする一方で、一部の部分を動的に保持できます。言い換えると、ルートの動的な部分を分離することができます。たとえば

![静的なナビゲーションと商品情報、動的なカートとおすすめ商品を表示する部分プリレンダリングされた商品ページ](/_images/thinking-in-ppr.avif)

ユーザーがルートにアクセスすると

- 静的なルートシェルが提供され、高速な初期ロードを保証します
- シェルには、動的なコンテンツが非同期でロードされるホールが残ります
- 非同期ホールは並行してストリーミングされ、ページ全体のロード時間を短縮します

これは、ルート全体が完全に静的または動的である今日のアプリケーションの動作とは異なります。

部分プリレンダリングは、超高速な静的エッジ配信と完全な動的機能を兼ね備えており、静的サイトの生成と動的配信の利点を組み合わせて、[Web アプリケーションのデフォルトのレンダリングモデルになる](https://vercel.com/blog/partial-prerendering-with-next-js-creating-a-new-default-rendering-model) 可能性があると考えています。

## 部分プリレンダリングはどのように機能するか?

部分プリレンダリングは React の [並列 API](https://react.dev/blog/2021/12/17/react-conf-2021-recap#react-18-and-concurrent-features) を活用します。
そして、[Suspense](https://react.dev/reference/react/Sus​​pense) を使用して、何らかの条件が満たされるまで（データがロードされるなど）、アプリケーションの一部のレンダリングを延期します。

フォールバックは、他の静的コンテンツと一緒に最初の静的ファイルに埋め込まれます。ビルド時（または再検証時）に、ルートの静的な部分がプリレンダリングされ、残りの部分はユーザーがルートをリクエストするまで延期されます。

コンポーネントを Suspense でラップしても、コンポーネント自体が動的になるわけではなく（この動作を実現するために `unstable_noStore` を使用したことを思い出してください）、Suspense はルートの静的な部分と動的な部分の境界として使用されることに注意してください。

部分プリレンダリングの素晴らしいところは、それを使用するためにコードを変更する必要がないことです。Suspense を使用してルートの動的な部分をラップしている限り、Next.js はルートのどの部分が静的でどの部分が動的であるかを知ることができます。

> [!note]
>
> 部分プリレンダリングの設定方法については、[部分プリレンダリング（実験的）ドキュメント](https://nextjs.org/docs/app/api-reference/next-config-js/partial-prerendering) を参照するか、 [部分プリレンダリングのテンプレートとデモ](https://vercel.com/templates/next.js/partial-prerendering-nextjs) を試してください。この機能は **実験的** であり、**まだ本番環境の準備が整っていない** ことに注意してください。

## まとめ

要約すると、アプリケーションでのデータ取得を最適化するために次のことを行いました。

1. サーバーとデータベース間の待ち時間を減らすために、アプリケーションコードと同じリージョンにデータベースを作成しました
1. React Server Components を使用して、サーバー上のデータを取得します。これにより、高価なデータの取得とロジックをサーバー上に保持し、クライアント側の JavaScript バンドルを減らし、データベースの秘密がクライアントに公開されるのを防ぎます
1. SQL を使用して必要なデータのみを取得し、リクエストごとに転送されるデータ量と、メモリ内のデータを変換するために必要な JavaScript の量を削減しました
1. 合理的な判断とされる場合は、JavaScript を使用してのデータ取得を並列化します。
1. 遅いデータリクエストによりページ全体がブロックされるのを防ぎ、ユーザーが読み込みを待たずに UI とのやりとりを開始できるように、ストリーミングを実装しました
1. データ取得を必要なコンポーネントに移し、部分プリレンダリングに備えてルートのどの部分を動的にする必要があるかを分離します

次の章では、データを取得するときに実装する必要があるかもしれない 2 つの典型的なパターン「検索」と「ページネーション」について説明します。
